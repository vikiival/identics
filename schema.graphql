type Identity @entity {
  "Account address"
  id: ID!
  name: String @index
  legal: String
  web: String
  matrix: String
  email: String
  image: String
  twitter: String @index
  github: String
  discord: String
  usernames: [Username!] @derivedFrom(field: "identity")
  events: [Event!] @derivedFrom(field: "identity")
  subs: [Sub!] @derivedFrom(field: "identity")
  "Jugdement"
  judgement: Judgement
  registrar: Int
  hash: String
  "Basic"
  blockNumber: BigInt @index
  updatedAt: DateTime! @index
  createdAt: DateTime! @index
  origin: ChainOrigin!
  burned: Boolean!
  type: AddressType
  deposit: BigInt
}

type Registrar @entity {
  id: ID!
  address: String!
  blockNumber: BigInt @index
  updatedAt: DateTime! @index
  createdAt: DateTime! @index
  origin: ChainOrigin!
  fee: BigInt
  field: BigInt
}

type Authority @entity {
  id: ID!
  address: String!
  suffix: String!
  blockNumber: BigInt @index
  updatedAt: DateTime! @index
  createdAt: DateTime! @index
  origin: ChainOrigin!
}

type Sub @entity {
  id: ID!
  name: String!
  identity: Identity!
  blockNumber: BigInt @index
  updatedAt: DateTime! @index
  createdAt: DateTime! @index
  origin: ChainOrigin!
  type: AddressType
  deposit: BigInt
}

type Username @entity {
  id: ID!
  primary: Boolean!
  name: String! @index
  address: String! @index
  identity: Identity
  blockNumber: BigInt @index
  createdAt: DateTime! @index
  gracePeriod: BigInt @index
  status: UsernameStatus!
}

# Abstract entity to represent an event
# https://graphql.org/learn/schema/#interfaces
interface EventType {
  id: ID!
  blockNumber: BigInt
  timestamp: DateTime!
  caller: String!
  currentOwner: String
  interaction: Interaction!
  # version: Int!
  meta: String!
}

# Entity to represent an event defined by Interaction
type Event implements EventType @entity {
  id: ID!
  blockNumber: BigInt
  timestamp: DateTime!
  caller: String!
  currentOwner: String! # currentOwner
  interaction: Interaction!
  meta: String!
  identity: Identity!
  # version: Int!
}

enum ChainOrigin {
  RELAY
  PEOPLE
}

# Possible on-chain interactions that we listen for
enum Interaction {
  CREATE
  CLEAR
  DESTROY # this is forcible removal
  CHANGE
}

enum Judgement {
  Erroneous
  FeePaid
  KnownGood
  LowQuality
  OutOfDate
  Reasonable
  Unknown
}

enum UsernameStatus {
  Active
  Unbinding
  Queued
  Removed
}

enum AddressType {
  Ethereum
  Substrate
}


# type Account @entity {
#   "Account address"
#   id: ID!
#   transfersTo: [Transfer!] @derivedFrom(field: "to")
#   transfersFrom: [Transfer!] @derivedFrom(field: "from")
# }

# type Transfer @entity {
#   id: ID!
#   blockNumber: Int! @index
#   timestamp: DateTime! @index
#   extrinsicHash: String @index
#   from: Account!
#   to: Account!
#   amount: BigInt! @index
#   fee: BigInt! # fee is calculated at the best effort and may be zero for some old extrinsics
# }

# Entity to represent when the cache was last updated
# type CacheStatus @entity {
#   id: ID!
#   lastBlockTimestamp: DateTime!
# }